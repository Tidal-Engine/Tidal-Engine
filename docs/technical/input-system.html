<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Input System - Tidal Engine Documentation</title>
    <link rel="stylesheet" href="../assets/styles.css">
</head>
<body>
    <div class="container">
        <!-- Left Sidebar Navigation -->
        <nav class="sidebar-left">
            <h1>Tidal Engine</h1>

            <div class="nav-section">
                <h3>Getting Started</h3>
                <ul>
                    <li><a href="../index.html">Overview</a></li>
                    <li><a href="../development/architecture.html">Architecture</a></li>
                    <li><a href="../getting-started/quick-start.html">Quick Start</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <h3>Core Systems</h3>
                <ul>
                    <li><a href="rendering.html">Rendering System</a></li>
                    <li><a href="networking.html">Networking</a></li>
                    <li><a href="world-system.html">World System</a></li>
                    <li><a href="input-system.html" class="active">Input System</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <h3>Infrastructure</h3>
                <ul>
                    <li><a href="vulkan-infrastructure.html">Vulkan Infrastructure</a></li>
                    <li><a href="threading.html">Threading & Concurrency</a></li>
                    <li><a href="shaders.html">Shader System</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <h3>Development</h3>
                <ul>
                    <li><a href="../getting-started/build-system.html">Build System</a></li>
                    <li><a href="../development/performance.html">Performance</a></li>
                    <li><a href="../development/debugging.html">Debugging</a></li>
                </ul>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="content">
            <section class="section">
                <h1>Input System</h1>

                <h2>GameClientInput Architecture</h2>
                <p class="file-path">src/game/GameClientInput.cpp</p>
                <div class="info-box">
                    Dedicated input subsystem handling GLFW callbacks and state-dependent input processing.
                    Integrates with GameClient for game logic and world interaction.
                </div>

                <h3>Initialization</h3>
                <pre><code>// GameClient initializes input subsystem
m_input = std::make_unique&lt;GameClientInput&gt;(*this, m_window, m_camera);

// GameClientInput sets up GLFW callbacks
glfwSetKeyCallback(m_window, GameClientInput::keyCallback);
glfwSetCursorPosCallback(m_window, GameClientInput::mouseCallback);
glfwSetMouseButtonCallback(m_window, GameClientInput::mouseButtonCallback);
glfwSetScrollCallback(m_window, GameClientInput::scrollCallback);</code></pre>

                <h3>Input Processing</h3>
                <pre><code>// Main loop calls input processing
if (m_input) {
    m_input->processInput(deltaTime);
}

// Mouse capture control in GameClientInput
void GameClientInput::setMouseCaptured(bool captured) {
    m_mouseCaptured = captured;
    glfwSetInputMode(m_window, GLFW_CURSOR,
        captured ? GLFW_CURSOR_DISABLED : GLFW_CURSOR_NORMAL);
}</code></pre>

                <h2>Movement Controls</h2>
                <table>
                    <tr><th>Key</th><th>Action</th><th>Implementation</th></tr>
                    <tr><td>WASD</td><td>Horizontal Movement</td><td>Minecraft-style (X/Z plane only)</td></tr>
                    <tr><td>Space</td><td>Move Up</td><td>Pure Y-axis movement</td></tr>
                    <tr><td>Shift</td><td>Move Down</td><td>Pure Y-axis movement</td></tr>
                    <tr><td>Ctrl</td><td>Speed Boost</td><td>5x movement multiplier</td></tr>
                    <tr><td>Mouse</td><td>Look Around</td><td>FPS-style camera control</td></tr>
                    <tr><td>Mouse Wheel</td><td>FOV/Speed</td><td>Adjusts camera zoom</td></tr>
                </table>

                <pre><code>// Minecraft-style horizontal movement (Camera.cpp:26-46)
glm::vec3 horizontalFront = glm::normalize(glm::vec3(Front.x, 0.0f, Front.z));
glm::vec3 horizontalRight = glm::normalize(glm::vec3(Right.x, 0.0f, Right.z));

if (direction == CameraMovement::FORWARD)
    Position += horizontalFront * velocity;
if (direction == CameraMovement::UP)
    Position += glm::vec3(0.0f, 1.0f, 0.0f) * velocity; // Pure Y-axis</code></pre>

                <h2>Block Interaction</h2>
                <div class="method-signature">
                    <code>void GameClientInput::handleBlockInteraction(bool isBreaking)</code><br>
                    Handles block placement/breaking via raycasting. Delegates to GameClient for game logic.
                </div>

                <pre><code>// Block interaction in GameClientInput (updated architecture)
void GameClientInput::handleBlockInteraction(bool isBreaking) {
    if (m_gameClient.getGameState() != GameState::IN_GAME) return;

    // Create ray from camera
    const auto& camera = m_gameClient.getCamera();
    Ray ray(camera.getPosition(), camera.getFront());

    // Raycast through GameClient's public API
    auto chunkManager = m_gameClient.getChunkManager();
    BlockHitResult hit = m_gameClient.raycastVoxelsClient(ray, chunkManager, 5.0f);

    if (hit.hit) {
        if (isBreaking) {
            m_gameClient.onBlockBreak(hit.blockPosition);
        } else {
            glm::ivec3 placePosition = hit.blockPosition + glm::ivec3(hit.normal);
            BlockType selectedBlock = m_gameClient.getHotbarBlocks()[m_gameClient.getSelectedHotbarSlot()];
            m_gameClient.onBlockPlace(placePosition, selectedBlock);
        }
    }
}</code></pre>

                <h3>Input-to-GameClient Integration</h3>
                <pre><code>// Mouse button callback (static GLFW callback)
void GameClientInput::mouseButtonCallback(GLFWwindow* window, int button, int action, int mods) {
    auto* input = static_cast&lt;GameClientInput*&gt;(glfwGetWindowUserPointer(window));
    if (action == GLFW_PRESS) {
        if (button == GLFW_MOUSE_BUTTON_LEFT) {
            input->handleBlockInteraction(true);  // Break block
        } else if (button == GLFW_MOUSE_BUTTON_RIGHT) {
            input->handleBlockInteraction(false); // Place block
        }
    }
}</code></pre>

                <h2>UI Input States</h2>
                <div class="info-box">
                    GameClientInput adapts behavior based on GameClient state to prevent conflicts between game controls and UI interaction.
                </div>
                <pre><code>// State-dependent input handling in GameClientInput
void GameClientInput::processInput(float deltaTime) {
    auto gameState = m_gameClient.getGameState();

    switch (gameState) {
        case GameState::MAIN_MENU:
        case GameState::PAUSED:
            // Mouse free for UI interaction, no camera movement
            if (m_mouseCaptured) setMouseCaptured(false);
            break;

        case GameState::IN_GAME:
            // Full FPS controls, mouse captured for camera movement
            if (!m_mouseCaptured) setMouseCaptured(true);
            processKeyboardInput(deltaTime);
            // Mouse movement handled by callbacks
            break;

        case GameState::LOADING:
            // Minimal input processing during world load
            break;
    }
}

// ESC key toggles between IN_GAME and PAUSED
if (m_keys[GLFW_KEY_ESCAPE]) {
    auto currentState = m_gameClient.getGameState();
    if (currentState == GameState::IN_GAME) {
        m_gameClient.setGameState(GameState::PAUSED);
        setMouseCaptured(false);
    } else if (currentState == GameState::PAUSED) {
        m_gameClient.setGameState(GameState::IN_GAME);
        setMouseCaptured(true);
    }
}</code></pre>
            </section>
        </main>

        <!-- Right Sidebar - Table of Contents -->
        <aside class="sidebar-right">
            <div class="toc">
                <h4>On This Page</h4>
                <ul>
                    <!-- TOC will be dynamically generated -->
                </ul>
            </div>
        </aside>
    </div>

    <script src="../assets/nav.js"></script>
</body>
</html>