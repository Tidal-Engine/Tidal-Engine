<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architecture Overview - Tidal Engine Documentation</title>
    <link rel="stylesheet" href="../assets/styles.css">
</head>
<body>
    <div class="container">
        <!-- Left Sidebar Navigation -->
        <nav class="sidebar-left">
            <h1>Tidal Engine</h1>

            <div class="nav-section">
                <h3>Getting Started</h3>
                <ul>
                    <li><a href="../index.html">Overview</a></li>
                    <li><a href="architecture.html" class="active">Architecture</a></li>
                    <li><a href="../getting-started/quick-start.html">Quick Start</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <h3>Core Systems</h3>
                <ul>
                    <li><a href="../technical/rendering.html">Rendering System</a></li>
                    <li><a href="../technical/networking.html">Networking</a></li>
                    <li><a href="../technical/world-system.html">World System</a></li>
                    <li><a href="../technical/input-system.html">Input System</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <h3>Infrastructure</h3>
                <ul>
                    <li><a href="../technical/vulkan-infrastructure.html">Vulkan Infrastructure</a></li>
                    <li><a href="../technical/threading.html">Threading & Concurrency</a></li>
                    <li><a href="../technical/shaders.html">Shader System</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <h3>Development</h3>
                <ul>
                    <li><a href="../getting-started/build-system.html">Build System</a></li>
                    <li><a href="performance.html">Performance</a></li>
                    <li><a href="debugging.html">Debugging</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <h3>Reference</h3>
                <ul>
                    <li><a href="../api-reference.html">API Reference</a></li>
                </ul>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="content">
            <section class="section">
                <h1>Architecture Overview</h1>

                <p>The engine follows a client-server architecture even for single-player games, ensuring consistency and enabling seamless multiplayer support.</p>

                <h2>Core Components</h2>

                <div class="info-box">
                    <strong>GameClient</strong> <span class="file-path">src/game/GameClient.cpp</span><br>
                    Main client coordinator that orchestrates all client subsystems. Handles initialization, state management, and integration between subsystems.
                </div>

                <div class="info-box">
                    <strong>GameServer</strong> <span class="file-path">src/game/GameServer.cpp</span><br>
                    Server-side game logic, world state management, and multiplayer coordination.
                </div>

                <div class="info-box">
                    <strong>NetworkManager</strong> <span class="file-path">src/network/NetworkManager.cpp</span><br>
                    TCP-based networking for reliable client-server communication.
                </div>

                <h2>Client Subsystems</h2>

                <p>The GameClient has been refactored into specialized subsystems for better separation of concerns:</p>

                <div class="info-box">
                    <strong>GameClientRenderer</strong> <span class="file-path">src/game/GameClientRenderer.cpp</span><br>
                    Handles all rendering operations, Vulkan pipeline management, and frame rendering logic.
                </div>

                <div class="info-box">
                    <strong>GameClientInput</strong> <span class="file-path">src/game/GameClientInput.cpp</span><br>
                    Processes keyboard, mouse, and gamepad input. Handles GLFW callbacks and input state management.
                </div>

                <div class="info-box">
                    <strong>GameClientNetwork</strong> <span class="file-path">src/game/GameClientNetwork.cpp</span><br>
                    Manages client-side networking, message handling, and server communication.
                </div>

                <div class="info-box">
                    <strong>GameClientUI</strong> <span class="file-path">src/game/GameClientUI.cpp</span><br>
                    Handles ImGui-based user interface, menus, HUD, and debug windows.
                </div>

                <div class="info-box">
                    <strong>ClientChunkManager</strong> <span class="file-path">src/game/ClientChunkManager.cpp</span><br>
                    Manages client-side chunk loading, rendering, and mesh generation for the voxel world.
                </div>

                <div class="info-box">
                    <strong>ClientChunk</strong> <span class="file-path">src/game/ClientChunk.cpp</span><br>
                    Represents individual chunks on the client with mesh data and rendering capabilities.
                </div>

                <h2>Data Flow</h2>
                <pre><code>Player Input → GameClientInput → GameClient → GameClientNetwork → GameServer
                    ↓                            ↓                                   ↓
              Key/Mouse      GameClientRenderer   GameClientUI      World State ← Game Logic
                 Events           ↓                  ↓                    ↓
                              Vulkan API        ImGui Interface    ClientChunkManager
                                 ↓                  ↓                    ↓
                              Graphics Card      UI Elements        ClientChunk Meshes</code></pre>

                <h2>Subsystem Integration</h2>
                <p>GameClient acts as the main coordinator, initializing and orchestrating communication between subsystems:</p>
                <pre><code>GameClient::initialize() {
    // Initialize subsystems in dependency order
    m_renderer = std::make_unique&lt;GameClientRenderer&gt;(*this, m_device);
    m_input = std::make_unique&lt;GameClientInput&gt;(*this, m_window, m_camera);
    m_network = std::make_unique&lt;GameClientNetwork&gt;(*this);
    m_ui = std::make_unique&lt;GameClientUI&gt;(*this, m_window, m_device);
    m_chunkManager = std::make_unique&lt;ClientChunkManager&gt;(m_device, m_textureManager);
}</code></pre>

                <h2>Threading Model</h2>
                <table>
                    <tr><th>Thread</th><th>Responsibility</th><th>Implementation</th></tr>
                    <tr><td>Main Thread</td><td>Rendering, UI, Input</td><td><code>GameClient::run()</code> + subsystems</td></tr>
                    <tr><td>Server Thread</td><td>Game Logic, Physics</td><td><code>GameServer::run()</code></td></tr>
                    <tr><td>Network Thread</td><td>Client Networking I/O</td><td><code>GameClientNetwork</code></td></tr>
                    <tr><td>Worker Pool</td><td>Chunk Generation, Mesh Updates</td><td><code>ClientChunkManager</code></td></tr>
                </table>

                <h3>Main Thread Subsystem Coordination</h3>
                <pre><code>// Main game loop with subsystem delegation
while (m_running && !glfwWindowShouldClose(m_window)) {
    // Input processing
    if (m_input) {
        m_input->processInput(deltaTime);
    }

    // Network message processing
    if (m_gameState != GameState::MAIN_MENU && m_network) {
        m_network->processIncomingMessages();
    }

    // Rendering
    if (m_renderer) {
        updateTransforms(deltaTime);
        m_renderer->drawFrame();
    }
}</code></pre>

                <h2>Component Interaction</h2>

                <h3>Single Player Mode</h3>
                <p>Even in single-player mode, the engine runs a local server to maintain consistency with multiplayer architecture:</p>

                <pre><code>// Single-player initialization
GameServer localServer;
localServer.startLocal();  // No networking, direct communication

GameClient client;
client.connectToLocalServer(localServer);</code></pre>

                <h3>Multiplayer Mode</h3>
                <p>Multiplayer simply connects clients to a remote server instance:</p>

                <pre><code>// Multiplayer client (updated for subsystem architecture)
GameClient client;
if (!client.initialize()) {
    // Handle initialization error
}

// Connect through network subsystem
if (!client.getNetwork()->connectToServer("192.168.1.100", 7777)) {
    // Handle connection error
}

client.run();

// Dedicated server
GameServer server;
server.startDedicated(7777);  // Listen on port 7777</code></pre>

                <h2>State Management</h2>

                <h3>Game States</h3>
                <pre><code>enum class GameState {
    MAIN_MENU,      // Main menu interface
    WORLD_SELECTION,// World selection screen
    CONNECTING,     // Connecting to server
    LOADING,        // Loading world data
    IN_GAME,        // Active gameplay
    PAUSED,         // In-game pause menu
    SETTINGS,       // Settings interface
    QUIT            // Shutdown sequence
};</code></pre>

                <h3>State Transitions</h3>
                <div class="method-signature">
                    <code>void GameClient::setState(GameState newState)</code><br>
                    Handles state transitions with proper cleanup and initialization.
                </div>

                <pre><code>// Example state transition
void GameClient::setState(GameState newState) {
    // Cleanup current state
    switch (m_gameState) {
        case GameState::IN_GAME:
            glfwSetInputMode(m_window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
            break;
        // ... other cleanup
    }

    m_gameState = newState;

    // Initialize new state
    switch (newState) {
        case GameState::IN_GAME:
            glfwSetInputMode(m_window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
            break;
        // ... other initialization
    }
}</code></pre>

                <h2>Memory Management</h2>

                <h3>RAII Patterns</h3>
                <div class="info-box">
                    The engine extensively uses RAII (Resource Acquisition Is Initialization) for automatic resource management, particularly for Vulkan resources.
                </div>

                <pre><code>class GameClient {
    std::unique_ptr&lt;VulkanDevice&gt; m_device;              // Core Vulkan device
    std::unique_ptr&lt;TextureManager&gt; m_textureManager;    // Texture management
    std::unique_ptr&lt;ClientChunkManager&gt; m_chunkManager;  // Client chunk system

    // Subsystem components (initialized after core systems)
    std::unique_ptr&lt;GameClientRenderer&gt; m_renderer;      // Rendering subsystem
    std::unique_ptr&lt;GameClientInput&gt; m_input;           // Input subsystem
    std::unique_ptr&lt;GameClientNetwork&gt; m_network;       // Network subsystem
    std::unique_ptr&lt;GameClientUI&gt; m_ui;                // UI subsystem

    // Proper destruction order ensured by member order
    ~GameClient() {
        // Subsystems destroyed first (depend on core systems)
        // m_ui, m_network, m_input, m_renderer destroyed
        // Core systems destroyed last
        // m_chunkManager, m_textureManager, m_device
    }
};</code></pre>

                <h3>Resource Lifecycles</h3>
                <table>
                    <tr><th>Resource Type</th><th>Lifecycle</th><th>Managed By</th></tr>
                    <tr><td>Vulkan Buffers</td><td>Frame-based</td><td>GameClientRenderer</td></tr>
                    <tr><td>Chunk Data</td><td>Distance-based</td><td>ClientChunkManager</td></tr>
                    <tr><td>Chunk Meshes</td><td>Distance-based</td><td>ClientChunk</td></tr>
                    <tr><td>Textures</td><td>Application lifetime</td><td>TextureManager</td></tr>
                    <tr><td>Network Connections</td><td>Session-based</td><td>GameClientNetwork</td></tr>
                    <tr><td>Input State</td><td>Frame-based</td><td>GameClientInput</td></tr>
                    <tr><td>UI Elements</td><td>State-based</td><td>GameClientUI</td></tr>
                </table>

                <h2>Error Handling</h2>

                <h3>Exception Strategy</h3>
                <div class="warning-box">
                    <strong>Exception Policy:</strong><br>
                    • Vulkan errors: Check return codes, throw on critical failures<br>
                    • Network errors: Graceful degradation, retry mechanisms<br>
                    • File I/O: Exception-based error handling<br>
                    • Game logic: Assertion-based debugging in debug builds
                </div>

                <pre><code>// Vulkan error handling
VkResult result = vkCreateBuffer(device, &bufferInfo, nullptr, &buffer);
if (result != VK_SUCCESS) {
    throw VulkanException("Failed to create buffer: " + std::to_string(result));
}

// Network error handling
bool NetworkManager::sendMessage(const NetworkMessage& msg) {
    try {
        // Attempt to send
        return sendInternal(msg);
    } catch (const NetworkException& e) {
        // Log error and attempt reconnection
        reconnect();
        return false;
    }
}</code></pre>

                <h2>Subsystem APIs</h2>

                <p>Each subsystem provides a clean public interface for GameClient integration:</p>

                <h3>GameClientRenderer API</h3>
                <pre><code>class GameClientRenderer {
public:
    // Lifecycle
    bool initialize();
    void shutdown();

    // Frame rendering
    void drawFrame();
    void recreateSwapchain();

    // Resource management
    VulkanRenderer* getRenderer() const;
    VkDescriptorSet getDescriptorSet(uint32_t frameIndex) const;
};</code></pre>

                <h3>GameClientInput API</h3>
                <pre><code>class GameClientInput {
public:
    // Input processing
    void processInput(float deltaTime);

    // Mouse control
    void setMouseCaptured(bool captured);
    bool isMouseCaptured() const;

    // Static GLFW callbacks
    static void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);
    static void mouseCallback(GLFWwindow* window, double xpos, double ypos);
    static void mouseButtonCallback(GLFWwindow* window, int button, int action, int mods);
    static void scrollCallback(GLFWwindow* window, double xoffset, double yoffset);
};</code></pre>

                <h3>GameClientUI API</h3>
                <pre><code>class GameClientUI {
public:
    // Rendering
    void renderImGui(VkCommandBuffer commandBuffer);

    // UI state management
    void toggleDebugWindow();
    bool isShowingDebugWindow() const;
    void setShowChunkBoundaries(bool show);
    bool isShowingChunkBoundaries() const;

    // Atlas texture management
    VkDescriptorSet getAtlasTextureDescriptor() const;
};</code></pre>

                <h3>ClientChunkManager API</h3>
                <pre><code>class ClientChunkManager {
public:
    // Chunk management
    void setChunkData(const ChunkPos& pos, const ChunkData& data);
    void removeChunk(const ChunkPos& pos);
    void updateBlock(const glm::ivec3& worldPos, BlockType blockType);

    // Rendering
    size_t renderVisibleChunks(VkCommandBuffer commandBuffer, const Frustum& frustum);
    void renderChunkBoundaries(VkCommandBuffer commandBuffer, VkPipeline wireframePipeline,
                              const glm::vec3& playerPosition, VkPipelineLayout pipelineLayout,
                              VkDescriptorSet descriptorSet);

    // Statistics
    size_t getLoadedChunkCount() const;
    size_t getTotalVertexCount() const;

    // Voxel queries
    bool isVoxelSolidAtWorldPosition(int worldX, int worldY, int worldZ) const;
};</code></pre>

                <h2>Configuration System</h2>

                <h3>Settings Management</h3>
                <div class="method-signature">
                    <code>class ConfigManager</code><br>
                    Handles persistent settings storage and runtime configuration.
                </div>

                <pre><code>// Configuration hierarchy
~/.tidal-engine/
├── config.json          // User settings
├── keybinds.json        // Key bindings
└── servers.json         // Server list

// Example configuration
{
    "graphics": {
        "renderDistance": 8,
        "vsync": true,
        "fullscreen": false
    },
    "audio": {
        "masterVolume": 0.8,
        "effectsVolume": 0.9
    }
}</code></pre>
            </section>
        </main>

        <!-- Right Sidebar - Table of Contents -->
        <aside class="sidebar-right">
            <div class="toc">
                <h4>On This Page</h4>
                <ul>
                    <!-- TOC will be dynamically generated -->
                </ul>
            </div>
        </aside>
    </div>

    <script src="../assets/nav.js"></script>
</body>
</html>